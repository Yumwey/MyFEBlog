<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>CodeMoneky丶</title>
    <description>Yumwey's blog,use Jekyll and github pages.</description>
    <link>isunmonkey.com//</link>
    <atom:link href="isunmonkey.com//feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 19 Jan 2017 10:45:53 +0800</pubDate>
    <lastBuildDate>Thu, 19 Jan 2017 10:45:53 +0800</lastBuildDate>
    <generator>Jekyll v3.2.1</generator>
    
      <item>
        <title>前端资源跨域以及解决方案</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;1.同源策略&lt;/h3&gt;
&lt;p&gt;如果&lt;code class=&quot;highlighter-rouge&quot;&gt;协议&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;端口&lt;/code&gt;（如果指定了一个）和&lt;code class=&quot;highlighter-rouge&quot;&gt;主机&lt;/code&gt;对于两个页面是相同的，则两个页面具有相同的源。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;IE例外情况：&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;授信范围&lt;/code&gt;（Trust Zones）：两个相互之间高度互信的域名，如公司域名（corporate domains），不遵守同源策略的限制。&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;端口&lt;/code&gt;：IE未将端口号加入到同源策略的组成部分之中，因此 &lt;em&gt;http://company.com:81/index.html&lt;/em&gt;和&lt;em&gt;http://company.com/index.html&lt;/em&gt; 属于同源并且不受任何限制。&lt;br /&gt;
    &lt;strong&gt;这些例外是非标准的，其它浏览器也未做出支持，但会助于开发基于window RT IE的应用程序。&lt;/strong&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-1&quot;&gt;2.更改源策略:&lt;/h3&gt;
&lt;p&gt;对于相同主域的，可以通过设置document.domain进行跨域，即将其设置为当前域或者当前域的超级域，比如：主页www.isunmonkey.com，则可以将子页和主页的document.domain都设置为：isunmonkey.com，这样就实现了不同页面之间的调用.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; //a页面:www.isunmonkey.com
 document.domain = 'isunmonkey.com';
 var hls = HTMLIframe.contentWindow.document;    //获取到当前页面嵌套iframe的内容
 //b页面
 document.domain = 'isunmonkey.com'
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-2&quot;&gt;3.跨源网络访问&lt;/h3&gt;
&lt;p&gt;     同源策略控制了不同源之间的访问和交互，交互分为三类：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;通常允许进行跨域写操作（Cross-origin writes）。例如链接（links），重定向以及表单提交。特定少数的HTTP请求需要添加 preflight。&lt;/li&gt;
    &lt;li&gt;通常允许跨域资源嵌入（Cross-origin embedding）。这个理解简单，譬如你在页面添加img,a，script标签等，都可以直接添加外部URI请求对应资源&lt;/li&gt;
    &lt;li&gt;通常不允许跨域读操作（Cross-origin reads）。但是可以通过JSONP,CORS，外嵌脚本等进行不同域的资源读. &lt;code class=&quot;highlighter-rouge&quot;&gt;X-Frame-Options&lt;/code&gt;可以防止当前页面被iframe引用
      &lt;h3 id=&quot;section-3&quot;&gt;3.阻止跨域访问&lt;/h3&gt;
    &lt;/li&gt;
    &lt;li&gt;阻止跨域写操作，只要检测请求中的一个不可测的标记(CSRF token)即可，这个标记被称为Cross-Site Request Forgery (CSRF) 标记。必须使用这个标记来阻止页面的跨站读操作。
所谓CSRF,就是 通常说的跨站请求伪造，是一种Web攻击方式，而CSRF token则是一种防御CSRF攻击的方式，通过后端每次生成请求的token返回给页面表单，在客户端数据提交的时候，服务端会验证当前请求参数中携带的token，从而有效的规避CSRF攻击。所以这里作为阻止跨域操作&lt;/li&gt;
    &lt;li&gt;阻止资源的跨站读取，需要保证该资源是不可嵌入的。阻止嵌入行为是必须的，因为嵌入资源通常向其暴露信息。&lt;/li&gt;
    &lt;li&gt;阻止跨站嵌入，确保你得资源不能是以上列出的可嵌入资源格式。多数情况下浏览器都不会遵守Conten-Type消息头。例如，如果你在&lt;script&gt;标签中嵌入HTML文档，浏览器仍将HTML解析为Javascript。只要你的资源不作为你站点的入门点，你依然跨域使用token阻止嵌入&lt;/script&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;api&quot;&gt;4.跨源脚本API访问&lt;/h3&gt;
&lt;p&gt;Javascript的APIs中，如 &lt;strong&gt;iframe.contentWindow&lt;/strong&gt;, &lt;strong&gt;window.parent&lt;/strong&gt;, &lt;strong&gt;window.open&lt;/strong&gt; 和 &lt;strong&gt;window.opener&lt;/strong&gt; 允许文档间直接相互引用。当两个文档的源不同时，这些引用方式将对 Window 和 Location对象的访问添加限制。可以使用window.postMessage 作为替代方案，提供跨域文档间的通讯。&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;5.跨源数据存储访问&lt;/h3&gt;
&lt;p&gt;存储在浏览器中的数据，如localStorage和IndexedDB，以源进行分割。每个源都拥有自己单独的存储空间，一个源中的Javascript脚本不能对属于其它源的数据进行读写操作。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;window.name属性可以用来临时存储数据，可以跨域访问。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Cookies使用不同的源定义方式。一个页面可以为本域和任何父域设置cookie，只要是父域不是公共后缀（public suffix）即可。Firefox和Chrome使用Public Suffix List决定一个域是否是一个公共后缀（public suffix）。不管使用哪个协议（HTTP/HTTPS）或端口号，浏览器都允许给定的域以及其任何子域名(sub-domains)来访问cookie。设置cookie时，你可以使用Domain，Path，Secure，和Http-Only标记来限定其访问性。读取cookie时，不会知晓它的出处。尽管使用安全的https连接，任何可见的cookie都是使用不安全的连接设置的。&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;6.跨域解决方案&lt;/h3&gt;
&lt;p&gt;跨域并非是浏览器或者安全协议限制了发起跨站请求，而是请求正常发起，但是请求返回结果被浏览器拦截了。但是部分浏览器（FF,Chrome）不支持HTTPS到HTTP的请求发起，会直接被浏览器阻止。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;HTTP访问控制（CORS）
    &lt;blockquote&gt;
      &lt;p&gt;CORS也称跨域资源共享，其实现方式是通过新增部分HTTP请求首部（header），来给服务端增加对请求来源的声明，最基础的实现方式是：服务端通过设置Access-Control-Allow-Origin（&lt;code class=&quot;highlighter-rouge&quot;&gt;允许请求源&lt;/code&gt;）来开放其他域对当前域接口的请求，前端实现和以往并没有区别。另外，对那些会对服务器数据造成破坏性影响的 HTTP 请求方法（特别是 GET 以外的 HTTP 方法，或者搭配某些MIME类型的POST请求），标准强烈要求浏览器必须先以 OPTIONS 请求方式发送一个预请求(preflight request)，从而获知服务器端对跨源请求所支持 HTTP 方法。&lt;/p&gt;
      &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var xhr = new XMLHttpRequest();
xhr.open('POST','www.baidu.com/getSearch',true);
xhr.onreadystate = onreadystate;
xhr.send(param);
var onreadystate = function(){
    // 请求状态和返回
}
&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
      &lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt; CORS并不兼容IE10以下的IE浏览器，但是IE8 和 9 通过 XDomainRequest 对象来实现CORS&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;JSONP（JSON with Padding）
    &lt;blockquote&gt;
      &lt;p&gt;通过上文对同源策略的介绍我们可以知道，客户端可以通过部分标签嵌入的方式实现资源的跨域，比如&lt;script&gt;,&lt;img /&gt;等，而JSONP就是通过嵌入script标签的方式实现对外域资源的读取操作。JSONP和JSON不同，JSON是一种是具备简单结构的纯文本，是现在数据传输的主流方式，区别于以往XML,JSON更加简洁高效而且更易于维护和编写，JSONP则是包含回调函数和数据格式的JSON使用模式。它允许服务端通过集成Script tags返回给客户端，客户端嵌入到当前调用页面来实现资源跨域。&lt;/script&gt;&lt;/p&gt;
      &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  //需要请求跨域资源的页面:a.html
    &amp;lt;script src=&quot;//www.isunmonkey.com/a.html?type=json&amp;amp;callback=getjsonp&quot;&amp;gt;
    // 上面type表示向服务端请求的参数,本地的回调函数是getjsonp
    &amp;lt;script&amp;gt;
       function getjsonp(data){
           console.log(data)   //显示接受到的数据
       }
    &amp;lt;/script&amp;gt;
    //服务端将会返回下面代码
    getjsonp({
        type:'json',
        name:'yw',
        sex:'man'
    })
    //JQ实现
    $.ajax({
       dataType:'jsonp',
       type:'get',
       url:'//isunmonkey.com/a.html?type=json',
       jsonp:'callback',
       jsonpCallback:'getjsonp',
       success:function(data){
           console.log(data)  //输出数据
       }
    })
&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
      &lt;p&gt;JSONP原理也非常容易理解，上文提到实现思路是通过嵌入外部资源的方式。所以原理如下代码:&lt;/p&gt;
      &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; //a.html
 &amp;lt;script&amp;gt;
   function getjson(data){
       console.log(data);
   }
 &amp;lt;/script&amp;gt;
 &amp;lt;script src=&quot;//isunmonkey.com/a.js&quot;&amp;gt;
 //a.js源码
 getjson({
   name:'yw',
   sex:'man'
 })
&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
      &lt;p&gt;在a页面实现了一个方法getjson，调用外部js：a.js,在a.js中引用了getjson方法，而JSONP的区别就是对函数getjson的引用是通过服务端动态载入。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; JSONP和CORS的主要区别还是JSONP只支持GET方式的请求，CORS除了对不安全请求推荐OPTION请求外，适用于所有请求&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;document.domain
    &lt;blockquote&gt;
      &lt;p&gt;上文已经解释，值得注意的是,document.domian只能设置当前域的超级域，所以它只适用于不同子域之间的交互&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;window.name
    &lt;blockquote&gt;
      &lt;p&gt;在窗口创建后，当前窗口下的所有新载入页面都共享同一个name,并且每个页面都具备对window.name的读写操作。&lt;strong&gt;注意:&lt;/strong&gt; 这里所说的新载入的页面依然是相同域名下的子页面，对于不同域，window.name依然为空。比如：在&lt;code class=&quot;highlighter-rouge&quot;&gt;a.com&lt;/code&gt;中设置name为&lt;code class=&quot;highlighter-rouge&quot;&gt;yw&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;a.com/b.html&lt;/code&gt;中读取name为&lt;code class=&quot;highlighter-rouge&quot;&gt;yw&lt;/code&gt;,但是在&lt;code class=&quot;highlighter-rouge&quot;&gt;b.com&lt;/code&gt;中，name依然是空，所以window.name依然局限于同源策略。所以会遇到如下问题：&lt;/p&gt;
      &lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;c1&quot;&gt;//a.html&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;//&amp;lt;iframe id=&quot;bif&quot; style=&quot;display:none&quot; src=&quot;b.com/b.html&quot;&amp;gt;&amp;lt;iframe&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;script&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;bif&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getElementById&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'bif'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;bif&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;onload&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
          &lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;bif&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;contentWindow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//报错：a.com和b.com不同源，无法回去到b.com的name值&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/script&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;gt;
&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//b.html&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;window&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;yw&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
      &lt;p&gt;当然，既然是window.name被称为JSONP的最优替代方案，还是有越过同源策略的解决方案，利用iframe的跨域能力，在iframe的onload的方法执行的时候，重置iframe的src为当前域同域，具体如下：&lt;/p&gt;
      &lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;c1&quot;&gt;//a页面&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;script&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;bif&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getElementById&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'bif'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;bif&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;onload&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;bif&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;src&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'about:blank'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;//此处原理就是在iframe加入后，将iframe地址替换为当前域，便绕过了不同域限制&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;bif&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;contentWindow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//报错：a.com和b.com不同源，无法回去到b.com的name值&lt;/span&gt;
      &lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;removeChild&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;bif&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;//获取到数据后将当前iframe移除，防止页面当前iframe重复刷新&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/script&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;niginx反向代理(网上方案很多，目前个人觉得是最佳解决方案)&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 17 Jan 2017 00:00:00 +0800</pubDate>
        <link>isunmonkey.com//http/2017/01/17/cors.html</link>
        <guid isPermaLink="true">isunmonkey.com//http/2017/01/17/cors.html</guid>
        
        <category>blog</category>
        
        
        <category>Http</category>
        
      </item>
    
  </channel>
</rss>
